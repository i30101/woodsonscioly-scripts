{"mode":"Text","textContent":"#pragma region VEXcode Generated Robot Configuration\n// Make sure all required headers are included.\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <math.h>\n#include <string.h>\n\n\n#include \"vex.h\"\n\nusing namespace vex;\n\n// Brain should be defined by default\nbrain Brain;\n\n\n// START IQ MACROS\n#define waitUntil(condition)                                                   \\\n  do {                                                                         \\\n    wait(5, msec);                                                             \\\n  } while (!(condition))\n\n#define repeat(iterations)                                                     \\\n  for (int iterator = 0; iterator < iterations; iterator++)\n// END IQ MACROS\n\n\n// Robot configuration code.\nmotor MotorGroup1MotorA = motor(PORT1, false);\nmotor MotorGroup1MotorB = motor(PORT12, true);\nmotor_group MotorGroup1 = motor_group(MotorGroup1MotorA, MotorGroup1MotorB);\n\nmotor MotorGroup7MotorA = motor(PORT7, true);\nmotor MotorGroup7MotorB = motor(PORT6, false);\nmotor_group MotorGroup7 = motor_group(MotorGroup7MotorA, MotorGroup7MotorB);\n\n#pragma endregion VEXcode Generated Robot Configuration\n\n\n\n/* ---------------- ROBOT MOVEMENT CONTROL ---------------- */\ndouble cmPerSecond = 0;\ndouble RPM = 0;\n\ndouble quarterTurn = 16;\n\nvoid robotTurn(double times) {\n  double spinTime = quarterTurn * times / cmPerSecond;\n  // wait(spinTime * 1000, msec);\n  wait(2000, msec);\n  MotorGroup1.stop();\n  MotorGroup7.stop();\n}\n\n/* ---------------- MOVEMENT TRACKING ---------------- */\nstruct Movement {\n  int movement;\n  double units;\n};\n\n// saved variables\nMovement movements[100] = {};\nint currentIndex = 0;\ndouble totalDistance = 0;\n\nvoid addMovement(int movement, double units, double distance) {\n  movements[currentIndex] = {movement, units};\n  currentIndex++;\n  totalDistance += distance;\n}\n\nvoid goForward(double spaces) { addMovement(0, spaces, 50.0 * spaces); }\nvoid goBack(double spaces) { addMovement(1, spaces, 50.0 * spaces); }\nvoid goRight(double spaces) { addMovement(2, spaces, 50.0 * spaces); }\nvoid goLeft(double spaces) { addMovement(3, spaces, 50.0 * spaces); }\nvoid turnRight(double times) { addMovement(4, times, quarterTurn * times); }\nvoid turnLeft(double times) { addMovement(5, times, quarterTurn * times); }\n\nvoid run(double targetTime) {\n  cmPerSecond = totalDistance / targetTime;\n  double rotations = totalDistance / 20.0;\n  double RPS = rotations / targetTime;\n  RPM = RPS * 60.0;\n\n  Brain.Screen.clearScreen();\n  Brain.Screen.print(\"total distance: %f\", totalDistance);\n  Brain.Screen.newLine();\n  Brain.Screen.print(\"cm per second: %f\", cmPerSecond);\n  Brain.Screen.newLine();\n  Brain.Screen.print(\"RPM: %f\", RPM);\n  \n  MotorGroup1MotorA.setVelocity(RPM, rpm);\n  MotorGroup1MotorB.setVelocity(RPM, rpm);\n  MotorGroup7MotorA.setVelocity(RPM, rpm);\n  MotorGroup7MotorB.setVelocity(RPM, rpm);\n\n  for (auto &m : movements) {\n    switch(m.movement) {\n      case 0:\n        MotorGroup7.spinFor(forward, m.units * 2.5, turns);\n        break;\n      case 1:\n        MotorGroup7.spinFor(reverse, m.units * 2.5, turns);\n        break;  \n      case 2:\n        MotorGroup1.spinFor(forward, m.units * 2.5, turns);\n        break;  \n      case 3:\n        MotorGroup1.spinFor(reverse, m.units * 2.5, turns);\n        break;  \n      case 4:\n        MotorGroup1MotorA.spin(forward);\n        MotorGroup1MotorB.spin(reverse);\n        MotorGroup7MotorA.spin(reverse); \n        MotorGroup7MotorB.spin(forward);\n        robotTurn(m.units);\n        break;  \n      case 5:\n        MotorGroup1MotorA.spin(reverse);\n        MotorGroup1MotorB.spin(forward);\n        MotorGroup7MotorA.spin(forward);\n        MotorGroup7MotorB.spin(reverse);\n        robotTurn(m.units);\n        break;  \n      default:\n        Brain.Screen.clearScreen();\n        Brain.Screen.print(\"error\");\n        break;\n    }\n  }\n}\n\nint main() {\n  // ADD TARGET TIME!!!\n  double TARGET_TIME = 60;\n\n  goForward(1.76);\n  goBack(1);\n  goRight(3);\n  goForward(0.6);\n  goBack(0.6);\n  goLeft(2);\n  goBack(0.26);\n  goForward(0.1);\n  goRight(0.1);\n\n  /* ---------------- DO NOT EDIT ANYTHING BELOW! NO! ---------------- */\n  run(TARGET_TIME);\n}\n","textLanguage":"cpp","rconfig":[{"port":[1,12],"name":"MotorGroup1","customName":false,"deviceType":"MotorGroup","deviceClass":"motor_group","setting":{"fwd":"forward","rev":"reverse","motor_a_reversed":"false","motor_b_reversed":"true"},"triportSourcePort":22},{"port":[7,6],"name":"MotorGroup7","customName":false,"deviceType":"MotorGroup","deviceClass":"motor_group","setting":{"fwd":"forward","rev":"reverse","motor_a_reversed":"true","motor_b_reversed":"false"},"triportSourcePort":22}],"slot":0,"platform":"IQ","sdkVersion":"20230818.11.00.00","appVersion":"3.0.4","minVersion":"3.0.0","fileFormat":"1.2.0","icon":"","targetBrainGen":"First","v5SoundsEnabled":false,"target":"Physical"}